\documentclass[12pt]{article}
\usepackage{geometry}
\geometry{a4paper, total={170mm,257mm},left=20mm, top=20mm,}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=black]{hyperref}
\usepackage{bookmark}
\usepackage{listings}
\usepackage{enumitem}
\usepackage[autostyle, english = american]{csquotes}
\usepackage{courier}
\usepackage{mdframed}
\begin{document}
\begin{titlepage}
\title {Labtainer Framework Development Guide}
\maketitle

\vspace{2.0in}
This document was created by United States Government employees at 
The Center for Cybersecurity and Cyber Operations (C3O) at the Naval Postgraduate School NPS. 
Please note that within the United States, copyright protection is not available for any works created  
by United States Government employees, pursuant to Title 17 United States Code Section 105.   
This document is in the public domain and is not subject to copyright. 
\end{titlepage}
\tableofcontents
\newpage
\section {Introduction}
This document is intended for use by developers who maintain the
Labtainer framework.  It is also applicable to lab designers who wish
to follow Labtainers configuration managment and testing conventions for  their labs.
It does not address the mechanics lab creation, which is 
covered in the \textit {Labtainers Lab Designer User Guide}.

\begin{flushleft} 
{\bf Note:} 
The Labtainer framework is developed within and for Linux environments using the command line.
\end{flushleft} 


\section{Installation}
\subsection{Developer Software Prerequisites}
Labtainers is primarily implemented using python3.  The containers within a lab include python2 scripts that are
part of the framework, e.g., functions that collect student artifacts.  The following packages are required on a
Linux distribution to support Labtainer framework development.
\begin {itemize}
\item {\bf git}
\item {\bf make}
\item {\bf g++}
\item {\bf Latex} (texlive-full)
\item {\bf Docker (Community Edition)} [See {\bf Docker Installation} Section]
\item {\bf pip3} {\tt apt-get install python3-pip}
\item {\bf dateutil} {\tt pip3 install py-dateutil}
\item {\bf xdotool} 
\item {\bf VirtualBox} 
\end {itemize}

The VirtualBox product is used to to run Labtainer VMs for testing.  Currently, tests are performed on 
Ubuntu16 and Ubuntu18 VMs, the former tests backwards compatability of the frameworks python3 support.

\subsection{Getting Labtainers from Github}

In a Linux terminal, change the working directory into the directory you want to store Labtainers.
\begin{flushleft} Run this in the terminal: \end{flushleft}
\begin{center} {\tt git clone https://github.com/mfthomps/Labtainers.git} \end{center} 

\subsection{Setting up the Development Environment}
\begin {itemize}
\item Disable any auto-updates on your machine as this may interfere with 'apt-get' requests you may have during development.
\item Modify your ~/.bashrc file.
    \begin{enumerate}
    \item Add {\bf LABTAINER\_DIR} as an environment variable and set its value as the path to the {\tt  /Labtainers} directory. 
    \item Modify the \$PATH to include {\tt ./bin} and {\tt \$LABTAINER\_DIR/scripts/designer/bin}.
    \item In summary, your ~/.bashrc should include something like this:
	    \lstset{basicstyle=\footnotesize\ttfamily,
		    breaklines=true
	    	    framextopmargin=50pt
		    frame=single,
		    language=bash}
	    \begin{mdframed}
	    \begin{lstlisting}
export LABTAINER_DIR=$HOME/Labtainers
export TEST_REGISTRY="YES"
if [[ ":$PATH:" != *":./bin:"* ]]; then
  export PATH="${PATH}:./bin:$LABTAINER_DIR/scripts/designer/bin"
fi
	    \end{lstlisting}
	    \end{mdframed}
    \item cd into \$LABTAINER\_DIR/setup\_scripts:
	    \begin{itemize}
    		\item Run pull-all.py to get all base docker images.
    		\item Run build-docs.sh to build the lab manuals for all labs.
	    \end{itemize}
    \item cd into \$LABTAINER\_DIR/tool-src/capinout and run {\tt ./mkit.sh}
    \end{enumerate}
\end {itemize}


\subsection{Docker Installation}
For full and convenient installation of Docker and setting of Docker privileges, run  'install-docker-ubuntu.sh' in 'setup\_scripts', assuming you are developing in Ubuntu. {\bf Note:} Make sure to run the script as user (not sudo), so that your user can be added to the Docker group.\\ 
    
\noindent Reboot the system, so that user receives Docker privileges.

    \begin {itemize}
    \item If on a different Linux distribution look in the same folder for your corresponding distribution (CentOS, Debian, Fedora). 
    \item If your Linux distribution is none of these, please view Docker's webpage documentation to learn how to install Docker and set Docker privileges on your machine.
    \item {\bf NOTE:} These install-docker scripts include the installation of other packages outside Docker that are necessary for building labs. 
    \end {itemize}



\section {Framework implementation overview}
\subsection{Implementation elements}
The Labtainer framework implementation is primarily python scripts.  A number of the 
top level scripts share functions found in scripts/labtainer-student/{\bf bin}/labutils.py.  The 
top level scripts are organized as follows:

\begin{itemize}
	\item {\bf Student} \begin{itemize}
\item {\tt labtainer} (start) and {\tt stoplab} -- In the labtainers-student/bin directory, these run on the 
Linux host and manage the pulling, starting and stopping of containers.  They also coordinate
collection of student artifacts.
\item Container scripts -- In the labtainers-student/{\bf lab\_bin} directory, these execute on
containers, e.g., to hook bash and parameterize containers.
	\end{itemize}

	\item {\bf Instructor} \begin{itemize}
\item {\tt gradelab} and {\tt stopgrader}-- Push student artifacts onto grader container and get assessment results.
\item Container scripts -- perform grading functions.
	\end{itemize}

	\item {\bf Developer} \begin{itemize}
\item Building -- rebuild in labtainers-student/bin 
\item Publishing labs -- labtainers/distrib/publish.py
\item Base Labtainer images -- scripts/designer/bin, create and publish the base images.
	\end{itemize}	

	\item {\bf Other} \begin{itemize}
\item VM appliances -- //host\_scripts, update and publish VM appliances as OVA files for 
VirtualBox and VMWare.
\item Regression testing of grading functions is performed by labtainer-instructor/regress.py.
Expected results are stored in the labtainer/testsets directory.
\item Regression testing of labs and grading combined: scripts in testsets/bin; data sets
are not distributed, they are in labtainer/simlab/<labname>  Get simlab data sets using
\begin{verbatim}
git clone https://gitlab.nps.edu/mfthomps/Labtainers-simlab.git/
\end{verbatim}

       \end{itemize}

\end{itemize}

\subsection{Control flow}
Student scripts, e.g., {\tt labtainer}, run from the scripts/labtainer-student directory.
That directory also contains the bin/labutils.py, which contains most of the framework
functions.

When a student container is first started "docker exec" is used
to run parameterize.sh on the container.

That script also invokes hookBash.sh, which adds the bash
sdtin/stout capturing hook, and adds the startup.sh call
into the .profile.

The startup.sh uses a lock to control which
terminal displays the instructions or grading.  In practice most
instructions are now pdf files.
The startup.sh invoked by student will source a student\_startup.sh if present.

\section{Distribution publishing}
The Labtainer framework is distributed via the c3o website as a tar file, or, optionally a
VM applicance (both VMWare and VirtualBox).  The Docker images are distributed via the Docker Hub.

The labtainer/distrib/mkdist.sh script runs on a Linux VM hosted on windows or Linux, and creates the distribution tar 
and copies it into a shared folder.  The mk-devel.sh script makes the developers version of the tar.
From that shared folder, the two tar files are copied to the 
\begin{verbatim}
\\my.nps.edu@SSL\DavWWWRoot\webdav\c30-staging\document\_library" 
\end{verbatim}
\noindent and then "Publish to Live" is 
performed on the Liferay site.

The distributions are created from a git repos, as described in section \ref{releases}.

\subsection{VM Appliances}
Two prepackaged VM appliances are maintained: one for VirtualBox, and one for VMWare.  Each include
their respective guest additions.  The VMs are maintained on a native Linux system using command line
utilities, e.g., VBoxManage.  The VMs are rigged to update Labtainers, including a pull of
baseline images, on each boot until the first lab is commenced.  Scripts named "export*" are
used to created the appliance files.  The scripts re-import into test images, which must be
manually tested.  The WinSCP script pushes new applicance images to the CyberCIEGE download
directory on the C3O web server.  (Wine and WinSCP must be installed on the Linux host that
manages the VMs.

The VM appliances should be updated or recreated whenever changes are made to Labtairer base
images, otherwise, they are not expected to be changed.  To revise the VM appliances, use the scripts
from host\_scripts on 
on the Linux system that hosts VirtualBox and VMWare to update the VM appliances so they contain the latest baseline images.
After the VM starts and updates the baseline images, use:
\begin{verbatim}
sudo dd if=/dev/zero of=/emptyfile bs=1M
sudo rm -fr /emptyfile
\end{verbatim}
\noindent to zero unused space and then run
\begin{verbatim}
./poweroffVB.sh
./compact.sh
\end{verbatim}
\noindent to compact the VM image.  Then export it:
\begin{verbatim}
./exportVB.sh
\end{verbatim}
\noindent This will create the appliance OVA image, and will create a test
VM from that appliance.  The test VM will start.  Use that to run ad-hoc
tests.

Do the same for vmware.

Then push the images to the web server, in our case this is the nps.box.com account
pointed to by the Labtainers web server.

The appliances automatically update the baselines and the Labtainer scripts on boot, so there
is only really advantage to doing this for baseline changes, since they take a while to download.

\subsubsection {installation sizes}
An initial install, including the base images, requires about 4GB.  Installing a larger lab,
e.g., snort, requires an additional 1GB.  Running bufoverflow added 22M.

\section {Source control and Configuration Management}
\label{releases}
This section describes Labtainers source control and mechanisms to support continuous
integration.  Labtainers is managed using git, Docker registries, and a set of custom scripts that control
rebuilding and publishing of artifacts.  Artifacts are published to test environments associated with each
development branch of the product.  Publishing releases for public distribution occurs after development
branches are tested and merged into the master git branch.

\subsection{Build artifacts}
Labtainers development creates the following artifacts:
\begin{itemize}
\item The distribution tar file for students
\item A distribution tar file for lab designers (which is a superset of that for students).
\item A test script tar distribution containing SimLab scripts. (These come from a seperately managed repo.)
\item The Docker container images for each lab.
\item The Docker container image for the grader.
\end{itemize}

The tar distributions are created using scripts from the {\tt distrib} directory.  The Docker images are built and published to
a Docker registry using the publish.py script, which includes file dependency logic to only rebuild images when one
of their sources change.  By default, the publish.py script pushes to a local registry rather than to the DockerHub.  
Updated images are pushed to the DockerHub as part of publishing a new revision of Labtainers.

\subsubsection{Build steps}
The following steps must be performed for each build to ensure distributions are based on the latest file versions.
These steps are implemented with in the {\tt full\_build.sh} script.
\begin{enumerate}
\item Pull the latest git version of the current branch with {\tt git pull}
\item Refresh branch registry from the premaster (unless building premaster) using {\tt refresh\_branch.py}
\item Rebuild and publish Labtainer base images using {\tt scripts/labdesigner/bin/mkbases.py}
\item Rebuild and publish labs using {\tt publish.py}
\item Create distribution tar files with {\tt mkall.sh}
\item Run smoke test on Ubuntu16 and Ubuntu18 machines using scripts in {\tt testsets/bin}
\end{enumerate}

\subsubsection{Base images}
Changes to base docker images referenced by the lab containers will trigger rebuilds.  Base docker images are extended by creating
new dockerfiles with ``.xtra'' file extensions.  
This lets us add features to a base without rebuilding all previous labs that use that base.  
While these ``.xtra'' images are built with docker files managed within the
designer/base\_dockerfiles directory they are not true base images.
Only the true base images are included in the initial distribution.  
In general, avoid changes to a base docker image because doing so could lead some installations
to include two copies of the base image, which are very much larger than most other Labtainer images.  
Modifcations to an xtra extension image will not affect existing installations that have run
some labs.  Whenever a new lab is started, if it relies on a newer version of the xtra extention, that will be pulled as needed for the 
lab container images.

When a lab container image is created, it is tagged with the base image name and its image ID (a checksum generated by Docker).
When a lab is started, the framework confirms it contains the appropriate base image.  If not, the user is prompted to download it.

\subsection{Releases and Container Images}
A Labtainers \textit{release} contains the set of artifacts described above.  File versions within the tar files
of a release are all pulled from the git \textit{master} git branch on the development system.  Docker container images within a release are built from a 
\textit{premaster} git branch as described below, and then pushed to DockerHub via the {\tt refresh\_mirror.py} script.

\subsubsection{The premaster branch}
Labtainers source control management includes a \textit{premaster} branch which shall always be on the workflow of 
creating new releases. All merges on the path to a release go through the premaster branch.  No changes are made to the master
branch.  The only way the master branch ever is updated is via a merge with the premaster branch, after all of its testing is 
complete.  This approach has two goals: 1) ensure that results of merge conflict resolution are tested prior to 
inclusion within the master, and allow us to test container images before they are published in a new version.  

Container images on DockerHub are
pushed from a registry containing images build from the premaster branch. The push occurs during the final merge from the
premaster branch into the master branch during a release step.  The images within the premaster registry are updated only through
a rebuild, i.e., {\tt full\_build.sh}.  Images are not not pushed from development registries directly to the premaster registry.

It is intended that no changes be made directly to the premaster branch, rather, changes are merged into the premaster from
other development branches.  Once a merge into the premaster commences, no hotfixes affecting build images should occur until
the merge completes and the premaster is merged into the master.

\subsection{Development branches}
Development of new features and fixes occur within development branches.
New branches are made off of the premaster branch, but not during a premaster merge.

\subsection{Test registries}
The test registries are used to test the premaster and development branches of Labtainers.

Test registries are named by their port numbers (currently, all test registries must reside on the same host).  
These port numbers are mapped to git branch names.  This mapping occurs in the 
config/registry.config file.
The rebuild.py command pulls from the registry associated with the current branch.

All development systems are intended to have the {\tt TEST\_REGISTRY} environment variable set to YES so that images are
pulled and pushed to the appropriate test registry.

Within the test systems and the development host , i.e., the computer that builds distributions and docker images, update 
the /etc/docker/daemon.json file to reflect new registries as "insecure".
\begin{verbatim}
    "insecure-registries": [
        "testregistry:5000",
        "testregistry:5001",
        "testregistry:5002",
        "testregistry:5003"
        "testregistry:5004"
    ]
\end{verbatim}
\noindent On the Linux system that hosts the development VMs, create the test registries using {\tt host\_scripts/start\_reg.sh}.

\subsection{Testing}
The smoketest.py scripts represents the test procedures for Labtainers.  
It is expected that local repo development branches will be tested prior to pushing them to GitHub.  Similarly, the
results of premaster branch merges are expected to be tested locally before it is pushed to GitHub. A test run
from a fresh pull from GitHub premaster branch is a prerequisite to publishing a new release.

Local bench testing, e.g., using {\tt rebuild} for a small set of labs, depends on the git workspace and the test registry for the current branch.
Local branch testing, i.e., use of full\_build.sh, uses the local repo.  It is up to the developer to ensure that is up to date.
Release testing pulls from the GitHub repo for the desired branch.


\subsection{Merging}
Development branches are merged into the premaster branch as part of creating a new release.
\begin{itemize}
\item Be sure that any and all new and changed files are commited in the development branch, and these have been tested.
\item Refresh the premaster registry to ensure it matches the DockerHub images: {\tt ./refresh\_mirror.py -r}
\item {\tt git checkout premaster}
\item {\tt git merge <dev branch>}
\item Fix any confilicts
\item Rebuild images using the premaster branch source: {\tt ./full\_rebuild.py}
\item Run smoketest.
\item Push premaster to GitHub: 
\begin{verbatim}
    git push --set-upstream origin premaster
\end{verbatim}
\end{itemize}

Revert to premaster in case of merge issues or other failures using {\tt revert\_premaster.sh}.
\begin{itemize}
\item Replace the premaster registry with current published images per DockerHub:
\begin{verbatim} 
    refresh_mirror.sh -r
\end{verbatim} 
\item Delete premaster branch
\item Recreate premaster branch:
\end{itemize}
\subsection{Examples}
Example: Create new branch to include changed lab and perhaps changed framework
Run new\_branch.py.  This will create a new git branch for the local repo and will allocate a test registry to the
new branch (for now, first updated manually by editing config/registry.config).  This script will update the 
assigned registry to fully match the premaster branch (SO DO NOT DO THIS WHILE A MERGE IS BEING DETANGLED).

The smoke test environment will pull tar file from SEED/labtainer.tar
Limitation: no concurrent smoke tests launched from same test system.
The config/labtainer.config file is modified when creating a branch test distribution to reflect the registry for
that branch.

The authoritative location for lab container images is the DockerHub registry.  If a merge to the premaster branch is
botched, use the reset\_premaster.py script to restore the premaster registry to match DockerHub, and to revert the
premaster git branch to match the master.


\section{Developer guidelines}
\subsection{Testing and Running Existing Labs}
When running labs, the goal is to force ourselves to run the distributed labs unless we have specific reasons to do otherwise.
Labtainers will use locally-created container images if they are present -- and these may be stale.
\begin{enumerate}[label=\Alph*]
	\item )   To ensure that you are running the latest version of the published lab (or version assocated with your current git branch), first delete the current version of the lab using setup\_scripts/removelab.sh.  

	\item )   If you find the lab to be broken, e.g., missing a file, please attempt to run "rebuild.py" on the lab. rebuild.py will ouput a log of issues. Report these findings to the lab author.  

	\item )   Always run removelab.sh after you have run an existing lab via rebuild.py.  

	\item )   Please review the lab's manual very closely. This is so that both the lab itself and the lab's manual can receive feedback for improvement. 
\end{enumerate}

\section {Maintenance notes}
When working on a significant change, do so in a distinct branch:
\begin{itemize}
\item Create a new branch: {\tt git checkout -b newbranch}
\item Make changes 
\item Push changes in progress {\tt git push --set-upstream origin newbranch}
\item Pull new branch from other repo -- first checkin all local changes or stash. 
\begin{itemize}
\item {\tt git pull}
\item {\tt git checkout newbranch}
\end{itemize}
\item After testing, merge to branch into master:
\begin{itemize}
\item Checkout master: {\tt git checkout master}
\item merge: {\tt git merge newbranch}
\end{itemize}
\end{itemize}

\section {Notes}
\subsection {Race condition on checklocal.sh output}
If an mynotify.py event causes an output from checklocal.py, that may conflict with
concurrent output from checklocal.py resulting from some program/script running.  In 
theory, the program/script should complete its run of checklocal before the program/script
actually gets to access the file that triggers a mynotify watch.  So, the latter's output
to the timestamped file is appended.  Further, the mynotify.py looks for an existing timestamped
file, and if not found, looks for one from the previous second.  This hack is an attempt to
keep the outputs merged.  It will fail if the access does not happen within a second of the
program start.  See the acl lab.

\subsection {temporal logic considerations}
When evaluating results from logfiles containing timestamps use FILE\_TS or FILE\_TS\_REGEX
to ensure you get timestamped values for only matching records. Reliance on goals.config to
matchany can result in timestamped results that don't corrolate to the desired record. 

\subsection {parameterizing the start.config}
A copy of the parameterized version of start.config is placed into 
labtainer-student/.tmp/<lab>/.  This ensures that subsequent runs of the lab always
have the same psuedo random values.

\subsection {Packaging}
The framework has not yet been adapted to use Linux package managers.
Currently, scripts are run from a workspace directory and python
paths are managed relatively between scripts.  

\subsection{Todo}
Change smoke test to look for email in expected results and set that as the email before starting a lab.
Validation should catch results.config naming of non-existent container.

The backups2 lab creates a loopback volume named myfs.img.  The lab does not dismount it.
This device will go away on a reboot.

\subsubsection{Docker problems}
The check\_nets.py tests for problems that sometimes crop up in Docker.  These include Linux routes defined
on the host for container networks that no longer exist.  And, loopback devices that are not properly deleted?
The file-deletion lab fails in a full smoketest, perhaps due to a lingering loopback device?
Lab must be completed prior to reboot of the host VM. Reflect that in Lab Manual.

The backups2 lab consumed a loopback device, leaving it define (as seen when running check\_nets.sh).  This
led the file-deletion lab to fail, being unable to get a loopback device.  Altered file-deletion to create the
"next" loopback device if it does not exist.

Metasploit lab now crashes the VM.  g\_array\_unref: assertion 'array' failed.   Leads to X server crash, loss of
desktop.  Perhaps only occurs after reboot, once, then works ok?  Created both containers with NO\_PRIVILEGE attribute
in start.config, seems to fix it?

\subsubsection{grader updates}
Automate detection of need to update a local grader image, e.g., in response to a fix to the grader.

\subsection{ongoing}
Updated framework and grader to use python3.  Intent is to not affect existing labs.  Need to publish centos-log2 and
backups2 due to changes in centos packages.  Changed grader and centos.xtra base dockerfiles.
Publish along with new update?   Will centos-log2 run with old framework?
This is begin done in the python3 branch of git.

Python3 changed semantics of randint.  Also changed random.seed to take a version number for compatable seeding.
Except version 3.5.2 is broken in that a string given as the seed causes a non-deterministic (time?) seed to be used.
This bug is fixed in 3.6.  Our grader container naturally installs 3.5.2, so we also install 3.6 from dead.snakes ppa
and change the links in /usr/bin/python3. The broken 3.5.2 version is also what comes with the Ubuntu used in the original
Labtainer VMs.  So, we will maintain support for python2 in the framework, and fall back to python2 if we detect 3.5.2.

Some html, e.g., for the softplc, want to visit fonts.googleapis.com.  If no gateway/dns is available, there is a long timeout.
add         ADD-HOST fonts.googleapis.com:127.0.0.1 to start.config to shut it up.

In the VM .profile, move the terminal creation functions to a seperate script run in background -- seems .profile must finish or VMWare Horizen 
borks the Terminal Server startup.

\subsection{bread crumbs}
If you get the dreaded "docker.service: Start request repeated too quickly.", then:
sudo systemctl daemon-reload
sudo systemctl restart docker

Builds may be "local", meaning they will use any local (untagged) copy of a base image.
Publishing NEVER draws from a local copy of a base image.
\end{document}
