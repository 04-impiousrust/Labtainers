\documentclass[12pt]{article}
\usepackage{geometry}
\geometry{a4paper, total={170mm,257mm},left=20mm, top=20mm,}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=black]{hyperref}
\usepackage{bookmark}
\usepackage{listings}
\usepackage{enumitem}
\usepackage[autostyle, english = american]{csquotes}
\usepackage{courier}
\usepackage{mdframed}
\begin{document}
\begin{titlepage}
\title {Labtainer Framework Development Guide}
\maketitle

\vspace{2.0in}
This document was created by United States Government employees at 
The Center for Cybersecurity and Cyber Operations (C3O) at the Naval Postgraduate School NPS. 
Please note that within the United States, copyright protection is not available for any works created  
by United States Government employees, pursuant to Title 17 United States Code Section 105.   
This document is in the public domain and is not subject to copyright. 
\end{titlepage}
\tableofcontents
\newpage
\section {Introduction}
This document is intended for use by developers who maintain the
Labtainer framework.  It does not address lab creation, which is 
covered in the \textit {Labtainers Lab Designer User Guide}.

\begin{flushleft} 
{\bf Note:} 
The Labtainer framework is based in Linux and is accessed through the Linux Terminal. 
\end{flushleft} 


\section{Developer Software Prerequisites}
\begin {itemize}
\item {\bf git}
\item {\bf make}
\item {\bf g++}
\item {\bf Latex} (texlive-full)
\item {\bf Docker (Community Edition)} [See {\bf Docker Installation} Section]
\item {\bf pip3} {\tt apt-get install python3-pip}
\item {\bf dateutil} {\tt pip3 install py-dateutil}
\item {\bf xdotool} 
\end {itemize}
\section{Getting Labtainers from Github}

In the Linux Terminal change working directory into the directory you want to store Labtainers.
\begin{flushleft} Run this in the terminal: \end{flushleft}
\begin{center} {\tt git clone https://github.com/mfthomps/Labtainers.git} \end{center} 

\section{Setting up the Development Environment}
\begin {itemize}
\item Disable any auto-updates on your machine as this may interfere with 'apt-get' requests you may have during development.
\item Modify your ~/.bashrc file.
    \begin{enumerate}
    \item Add {\bf Labtainer\_DIR} as another global variable and set its value as the path to the {\tt  /Labtainers} directory. 
    \item Modify the \$PATH to include {\tt ./bin} and {\tt \$LABTAINER\_DIR/scripts/designer/bin}.
    \item In summary, your ~/.bashrc should include something like this:
	    \lstset{basicstyle=\footnotesize\ttfamily,
		    breaklines=true
	    	    framextopmargin=50pt
		    frame=single,
		    language=bash}
	    \begin{mdframed}
	    \begin{lstlisting}
if [[ ":$PATH:" != *":./bin:"* ]]; then
  export LABTAINER_DIR=$HOME/Labtainers
  export PATH="${PATH}:./bin:$LABTAINER_DIR/scripts/designer/bin"
fi
	    \end{lstlisting}
	    \end{mdframed}
    \item cd into \$LABTAINER\_DIR/setup\_scripts:
	    \begin{itemize}
    		\item Run pull-all.py to get all base docker images.
    		\item Run build-docs.sh to build the lab manuals for all labs.
	    \end{itemize}
    \item cd into \$LABTAINER\_DIR/tool-src/capinout and run mkit.sh
    \end{enumerate}
\end {itemize}


\section{Docker Installation}
For full and convenient installation of Docker and setting of Docker privileges, run  'install-docker-ubuntu.sh' in 'setup\_scripts', assuming you are developing in Ubuntu. {\bf Note:} Make sure to run the script as user (not sudo), so that your user can be added to the Docker group.\\ 
    
\noindent Reboot system, so that user receives Docker privileges.

    \begin {itemize}
    \item If on a different Linux distribution look in the same folder for your corresponding distribution (CentOS, Debian, Fedora). 
    \item If your Linux distribution is none of these, please view Docker's webpage documentation to learn how to install Docker and set Docker privileges on your machine.
    \item {\bf NOTE:} These install-docker scripts include the installation of other packages outside Docker that are necessary for building labs. 
    \end {itemize}

\section{Testing and Running Existing Labs}
When running labs, the goal is to force ourselves to run the distributed labs unless we have specific reasons to do otherwise.
\begin{enumerate}[label=\Alph*]
	\item )   To ensure that you are running the latest version of the published lab, first delete the current version of the lab using setup\_scripts/removelab.sh.  

	\item )   If you find the lab to be broken, e.g., missing a file, please attempt to run "rebuild.py" on the lab. rebuild.py will ouput a log of issues. Report these findings to the lab author.  

	\item )   Always run removelab.sh after you have run an existing lab via rebuild.py.  

	\item )   Please review the lab's manual very closely. This is so that both the lab itself and the lab's manual can receive feedback for improvement. 
\end{enumerate}

\section{Overview of Labtainer Elements}
The Labtainer framework implementation is primarily python scripts.  A number of the 
top level scripts share functions found in scripts/labtainer-student/{\bf bin}/labutils.py.  The 
top level scripts are organized as follows:

\begin{itemize}
	\item {\bf Student} \begin{itemize}
\item Student {\tt labtainers} (start) and {\tt stoplab} -- In the labtainers-student/bin directory, these run on the 
Linux host and manage the pulling, starting and stopping of containers.  They also coordinate
collection of student artifacts.
\item Student container scripts -- In the labtainers-student/{\bf lab\_bin} directory, these execute on
containers, e.g., to hook bash and parameterize containers.
	\end{itemize}

	\item {\bf Instructor} \begin{itemize}
\item Instructor {\tt gradelab} and {\tt stopgrader}-- Push student artifacts onto grader container and get assessment results.
\item Instructor container scripts -- perform grading functions.
	\end{itemize}

	\item {\bf Developer} \begin{itemize}
\item Developer building -- rebuild.py in labtainers-student/bin and labtainers-instructor/bin.
\item Publishing labs -- labtainers/distrib/publish.py
\item Base Labtainer images -- scripts/designer/bin, create and publish the base images.
	\end{itemize}	

	\item {\bf Other} \begin{itemize}
\item VM appliances -- //host\_scripts, update and publish VM appliances as OVA files for 
VirtualBox and VMWare.
\item Regression testing of grading functions is performed by labtainer-instructor/regress.py.
Expected results are stored in the labtainer/testsets directory.
\item Regression testing of labs and grading combined: scripts in testsets/bin; data sets
are not distributed, they are in labtainer/simlab/<labname>  Get simlab data sets using
\begin{verbatim}
git clone https://gitlab.nps.edu/mfthomps/Labtainers-simlab.git/
\end{verbatim}

       \end{itemize}

\end{itemize}

\section {Control Flow}
Student scripts, e.g., start.py, run from the scripts/labtainer-student directory.
That directory also contains the bin/labutils.py, which contains most of the framework
functions.

When a student container is first started "docker exec" is used
to run parameterize.sh on the container.

That script also invokes hookBash.sh, which adds the bash
sdtin/stout capturing hook, and adds the startup.sh call
into the .profile.

The startup.sh uses a lock to control which
terminal displays the instructions or grading.  In practice most
instructions are now pdf files.
The startup.sh invoked by student will source a student\_startup.sh if present.

\section{Automation and Distributions}
The Labtainer framework is distributed via the c3o website as a tar file, or, optionally a
VM applicance (both VMWare and VirtualBox).  The Docker images are distributed via the Docker Hub.

The labtainer/distrib/mkdist.sh script runs on a Linux VM hosted on windows or Linux, and creates the distribution tar 
and copies it into a shared folder.  The mk-devel.sh script makes the developers version of the tar.
From that shared folder, the two tar files are copied to the 
\begin{verbatim}
\\my.nps.edu@SSL\DavWWWRoot\webdav\c30-staging\document\_library" 
\end{verbatim}
\noindent and then "Publish to Live" is 
performed on the Liferay site.

The distributions are created from a local git repo, i.e., it does not pull a new repo.  The scripts first highlights
changes that have not yet been locally committed.  The user must press q to continue, potentially ignoring local changes.
Distrubtions are made from the current git branch.

Two prepackaged VMs are maintained: one for VirtualBox, and one for VMWare.  Each include
their respective guest additions.  The VMs are maintained on a native Linux system using command line
utilities, e.g., VBoxManage.  The VMs are rigged to update labtainers, including a pull of
baseline images, on each boot until the first lab is commenced.  Scripts named "export*" are
used to created the appliance files.  The scripts re-import into test images, which must be
manually tested.  The WinSCP script pushes new applicance images to the CyberCIEGE download
directory on the C3O web server.  (Wine and WinSCP must be installed on the Linux host that
manages the VMs.

New baseline images are created using scripts/designer/bin/create\_all.sh.  Note its comment
about deleting all docker images first.  When new baselines are created, use the labtainer-scripts
on the native Linux system to update the VM appliances so they contain the latest baseline images.
After the VM starts and updates the baseline images, use:
\begin{verbatim}
sudo dd if=/dev/zero of=/emptyfile bs=1M
sudo rm -fr /emptyfile
\end{verbatim}
\noindent to zero unused space and then run
\begin{verbatim}
./poweroffVB.sh
./compact.sh
\end{verbatim}
\noindent to compact the VM image.  Then export it:
\begin{verbatim}
./exportVB.sh
\end{verbatim}
\noindent This will create the appliance OVA image, and will create a test
VM from that appliance.  The test VM will start.  Use that to run ad-hoc
tests.

Do the same for vmware.

Then push the images to the web server

The appliances automatically update the baselines and the Labtainer scripts on boot, so there
is only really advantage to doing this for baseline changes, since they take a while to download.
After running the poweron/poweroff scripts, then run the exportVM.sh to 

\section {installation sizes}
An initial install, including the base images, requires about 4GB.  Installing a larger lab,
e.g., snort, requires an additional 1GB.  Running bufoverflow added 22M.

\section {Maintenance notes}
When working on a significant change, do so in a distinct branch:
\begin{itemize}
\item Create a new branch: {\tt git checkout -b newbranch}
\item Make changes 
\item Push changes in progress {\tt git push --set-upstream origin newbranch}
\item Pull new branch from other repo -- first checkin all local changes or stash. 
\begin{itemize}
\item {\tt git pull}
\item {\tt git checkout newbranch}
\end{itemize}
\item After testing, merge to branch into master:
\begin{itemize}
\item Checkout master: {\tt git checkout master}
\item merge: {\tt git merge newbranch}
\end{itemize}
\end{itemize}

\section {Notes}
\subsection {Race condition on checklocal.sh output}
If an mynotify.py event causes an output from checklocal.py, that may conflict with
concurrent output from checklocal.py resulting from some program/script running.  In 
theory, the program/script should complete its run of checklocal before the program/script
actually gets to access the file that triggers a mynotify watch.  So, the latter's output
to the timestamped file is appended.  Further, the mynotify.py looks for an existing timestamped
file, and if not found, looks for one from the previous second.  This hack is an attempt to
keep the outputs merged.  It will fail if the access does not happen within a second of the
program start.  See the acl lab.

\subsection {temporal logic considerations}
When evaluating results from logfiles containing timestamps use FILE\_TS or FILE\_TS\_REGEX
to ensure you get timestamped values for only matching records. Reliance on goals.config to
matchany can result in timestamped results that don't corrolate to the desired record. 

\subsection {parameterizing the start.config}
A copy of the parameterized version of start.config is placed into 
labtainer-student/.tmp/<lab>/.  This ensures that subsequent runs of the lab always
have the same psuedo random values.

\subsection {Packaging}
The framework has not yet been adapted to use Linux package managers.
Currently, scripts are run from a workspace directory and python
paths are managed relatively between scripts.  

\subsection{Todo}
Change smoke test to look for email in expected results and set that as the email before starting a lab.
Validation should catch results.config naming of non-existent container.

The backups2 lab creates a loopback volume named myfs.img.  The lab does not dismount it.
This device will go away on a reboot.

\subsubsection{Docker problems}
The check\_nets.py tests for problems that sometimes crop up in Docker.  These include Linux routes defined
on the host for container networks that no longer exist.  And, loopback devices that are not properly deleted?
The file-deletion lab fails in a full smoketest, perhaps due to a lingering loopback device?
Lab must be completed prior to reboot of the host VM. Reflect that in Lab Manual.

The backups2 lab consumed a loopback device, leaving it define (as seen when running check\_nets.sh).  This
led the file-deletion lab to fail, being unable to get a loopback device.  Altered file-deletion to create the
"next" loopback device if it does not exist.

Metasploit lab now crashes the VM.  g\_array\_unref: assertion 'array' failed.   Leads to X server crash, loss of
desktop.  Perhaps only occurs after reboot, once, then works ok?  Created both containers with NO\_PRIVILEGE attribute
in start.config, seems to fix it?

\subsubsection{grader updates}
Automate detection of need to update a local grader image, e.g., in response to a fix to the grader.

\subsection{Continuous integration and delivery}
These notes describe a strategy for moving Labtainers into a continuous integration environment such as Jenkins.
The goal is to automate building and testing of Labtainers, with an ultimate goal of automating the delivery step as well.

Note that provisioning of new VM appliances is not within the scope of this section.  The deliverable components are the 
distribution tar files (one for students; and a superset for developers), and the Docker container images required for each lab.

\subsubsection{Building}
Labtainers development includes building the following items:
\begin{itemize}
\item The distribution tar file for students
\item A distribution tar file for lab designers (which is a superset of that for students).
\item A test script tar distribution containing SimLab scripts. (These come from a seperately managed repo.)
\item The Docker container images for each lab.
\item The Docker container image for the grader.
\end{itemize}

The tar distributions are created using scripts from the distrib directory.  The Docker images are built and published to
a Docker registry using the publish.py script, which includes ad-hoc file dependency logic to only rebuild images when one
of their sources change.  By default, the publish.py script pushes to a local registry rather than to the DockerHub.  
Updated images are pushed to the DockerHub as part of publishing a new revision of Labtainers.

Changes to base docker images referenced by the lab containers will trigger rebuilds.  Base docker images are extended by creating
new dockerfiles with ``.xtra'' file extensions.  
This lets us add features to a base without rebuilding all previous labs that use that base.  
While these ``.xtra'' images are built with docker files managed within the
designer/base\_dockerfiles directory they are not true base images.
Only the true base images are included in the initial distribution.  
In general, avoid changes to a base docker image because doing so could lead some installations
to include two copies of the base image, which are very much larger than most other Labtainer images.  
Modifcations to an xtra extension image will not effect existing installations that have run
some labs.  Whenever a new lab is started, if it relies on a newer version of the xtra extention, that will be pulled as needed for the 
lab container images.

When a lab container image is created, it is tagged with the base image name and its image ID (a checksum generated by Docker).
When a lab is started, the framework confirms it hosts the appropriate base image.  If not, the user is prompted to download it.

A Labtainers \textit{release} is defined as a set of Docker images and the distribution tar files.  File versions within the tar files
of a release are all based on the git \textit{master} git branch.  Docker container images of a release are built from a 
\textit{premaster} git branch as described below.

Labtainers source control management includes a \textit{premaster} branch which shall always be on the workflow of 
creating new releases. All merges on the path to a release go through the premaster branch.  No changes are ever made to the master
branch.  The only way the master branch ever is updated is via a merge with the premaster branch, after all of its testing is 
complete.  This approach has two goals: 1) ensure that results of merge conflict resolution are tested prior to 
inclusion within the master, and allow us to test container images before they are published in a new version.  
A Labtainers release shall always be accompanied by a push of the local 
develoment repo to the remote GitHub repo.

Container images on DockerHub are
pushed from a registry containing images build from the premaster branch. The push occurs during the final merge from the
premaster branch into the master branch during a release step.

It is intended that no changes be made directly to the premaster branch, rather, changes are merged into the premaster from
other development branches.  Once a merge into the premaster commences, no hotfixes affecting build images should occur until
the merge completes and the premaster is merged into the master.

The rebuild.py command pulls from the registry assocated with the current branch.

All development systems are intended to have the {\tt TEST\_REGISTRY} environment variable set such that images are
pulled and pushed to the appropriate test registry.

Example: Create new branch to include changed lab and perhaps changed framework
Run new\_branch.py.  This will create a new git branch for the local repo and will allocate a test registry to the
new branch (for now, first updated manually by editing config/registry.config).  This script will update the 
assigned registry to fully match the premaster branch (SO DO NOT DO THIS WHILE A MERGE IS BEING DETANGLED).

The smoke test environment will pull tar file from SEED/labtainer.tar
Limitation: no concurrent smoke tests launched from same test system.
The config/labtainer.config file is modified when creating a branch test distribution to reflect the registry for
that branch.

The authoritative location for lab container images is the DockerHub registry.  If a merge to the premaster branch is
botched, use the reset\_premaster.py script to restore the premaster registry to match DockerHub, and to revert the
premaster git branch to match the master.

The test registries are used to test the premaster and development branches of Labtainers.

Test registries are named by their port numbers (currently, all test registries must reside on the same host).  
These port numbers are mapped to git branch names.  This mapping occurs in the 
config/registry.config file.

Within the test environment host, i.e., the computer that builds distributions and docker images, Update 
the /etc/docker/daemon.json file to reflect new registries as "insecure"
\begin{verbatim}
    "insecure-registries": [
        "testregistry:5000",
        "testregistry:5001",
        "testregistry:5002",
        "testregistry:5003"
        "testregistry:5004"
    ]
\end{verbatim}


\subsection{ongoing}
Updated framework and grader to use python3.  Intent is to not affect existing labs.  Need to publish centos-log2 and
backups2 due to changes in centos packages.  Changed grader and centos.xtra base dockerfiles.
Publish along with new update?   Will centos-log2 run with old framework?
This is begin done in the python3 branch of git.

Python3 changed semantics of randint.  Also changed random.seed to take a version number for compatable seeding.
Except version 3.5.2 is broken in that a string given as the seed causes a non-deterministic (time?) seed to be used.
This bug is fixed in 3.6.  Our grader container naturally installs 3.5.2, so we also install 3.6 from dead.snakes ppa
and change the links in /usr/bin/python3. The broken 3.5.2 version is also what comes with the Ubuntu used in the original
Labtainer VMs.  So, we will maintain support for python2 in the framework, and fall back to python2 if we detect 3.5.2.

Some html, e.g., for the softplc, want to visit fonts.googleapis.com.  If no gateway/dns is available, there is a long timeout.
add         ADD-HOST fonts.googleapis.com:127.0.0.1 to start.config to shut it up.

In the VM .proile, move the terminal creation functions to a seperate script run in background -- seems .profile must finish or VMWare Horizen 
borks the Terminal Server startup.

\subsection{bread crumbs}
If you get the dreaded "docker.service: Start request repeated too quickly.", then:
sudo systemctl daemon-reload
sudo systemctl restart docker
\end{document}
